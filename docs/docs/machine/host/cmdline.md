---
title: Command-line interface
---

In the simplest usage scenario, the `cartesi-machine` command-line utility can be used to define a Cartesi Machine and run it until it halts.
The command-line utility, however, is very versatile.
It was designed to simplify the most common prototyping tasks.

## Initialization

<a name="first-cartesi-machine-example"></a>

The following command instructs `cartesi-machine` to build a Cartesi Machine.
The machine uses `rom.bin` as the ROM image, has 64MiB of RAM, uses `linux.bin` as the RAM image, and uses `rootfs.ext2` as the root file-system.
(The `rom.bin`, `linux.bin`, and `rootfs.ext2` files are generated by the [Emulator SDK](https://github.com/cartesi/machine-emulator-sdk), and sample files are available in the playground.)
Once initialization is complete, the machine executes the command `ls /bin` and exits.

```bash
playground:~$ cartesi-machine \
    --rom-image="/opt/cartesi/share/images/rom.bin" \
    --ram-length=64Mi \
    --ram-image="/opt/cartesi/share/images/linux.bin" \
    --flash-drive="label:root,filename:/opt/cartesi/share/images/rootfs.ext2" \
    -- "ls /bin"
```
The `--rom-image`, `--ram-image`, `--ram-length`, and `--flash-drive` command-line options have the values in the example as default, so these options can be omitted.
To remove these default settings, use the command-line options `--no-ram-image` and `--no-root-flash-drive`, respectively.
(The machine needs a ROM image, and, if needed, you can simply specify a different one.)

The simplified command-line is
```bash
playground:~$ cartesi-machine -- "ls /bin"
```
The output is
```
%machine.host.cmdline.ls
```
It shows the Cartesi Machine splash screen, followed by the listing of directory `/bin/`.
The listing was produced by the command that follows `--` separator in the command line.
The Linux kernel passes this unmodified to `/sbin/init`, and the Cartesi-provided `/sbin/init` script executes the command before gracefully halting the machine.

:::note
In many of the documentation examples, the utilities invoked from the command-line executed by a Cartesi Machine are in the default search path for executables. (This is setup by the Cartesi-provided `/sbin/init` script itself.)
When in doubt, or when using your own executables installed in custom locations, make sure to invoke them by using their full paths (e.g., `/bin/ls` or `/bin/sh` instead of simply `ls` and `sh`.)
:::

## Interactive sessions

By default, the `cartesi-machine` utility executes the Cartesi Machine non-interactive mode.
Verifiable computations must always be run in non-interactive sessions.
User interaction with a Cartesi Machine via the console is, after all, not reproducible.
Nevertheless, during development, it is often convenient to directly interact with the emulator, as if using a computer console.

The command-line option `-i` (short for `--htif-console-getchar`) instructs the emulator to monitor the console for input, and to make this input available to the Linux kernel.
Typically, this option will be used in conjunction with the `--` separator and the command `sh`, causing the Cartesi-provided `/sbin/init` script to drop into an interactive shell.
Interaction with the shell enables the exploration of the embedded Linux distribution from the inside.
Exiting the shell returns control back to `/sbin/init`, which then gracefully halts the machine.

For example, if an interactive session is started with the following command
```bash
playground:~$ cartesi-machine -i -- sh
```
it drops into the shell.
Running the command `ls /bin` causes the listing of directory `/bin` to appear.
The command `exit` causes the shell to exit.
The output is
```
Running in interactive mode!

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

cartesi-machine:/ # ls /bin
ls /bin
arch           dmesg          linux32        netstat        setserial
ash            dnsdomainname  linux64        nice           sh
base64         dumpkmap       ln             nuke           sleep
busybox        echo           login          pidof          stty
cat            egrep          ls             ping           su
chattr         false          lsattr         pipe_progress  sync
chgrp          fdflush        lsblk          printenv       tar
chmod          fgrep          mk_cmds        ps             touch
chown          findmnt        mkdir          pwd            true
compile_et     getopt         mknod          resume         umount
cp             grep           mktemp         rm             uname
cpio           gunzip         more           rmdir          usleep
cttyhack       gzip           mount          run-parts      vi
date           hostname       mountpoint     sed            watch
dd             kill           mt             setarch        wdctl
df             link           mv             setpriv        zcat
cartesi-machine:/ # exit
exit

Halted
Cycles: 5994261720
```
Note that the final cycle count is meaningless, as the machine repeatedly skips cycles forward when idle, from one timer interrupt to the next.

## Flash drives

The command-line option `--flash-drive=label:<label>,filename:<filename>` can be used to add between 1 and 8 flash drives to the Cartesi Machine.
Here, the string `<label>` is the *label* for the flash drive, and `<filename>` points to an *image file* with the initial contents of the flash drive.
When the image file contains a valid file-system, the Cartesi-provided `/sbin/init` script will automatically mount this file-system at `/mnt/<label>`.

To enable transparency, Cartesi Machine flash drives are mapped into the machine's 64-bit address space.
The start and length are set, respectively, by the `start:<number>` and `length:<number>` parameters to `--flash-drive`.

By default, the start of the first flash drive (which typically holds the root file-system) is set to the beginning of the second half of the address space (i.e., at offset 2<sup>63</sup>).
Additional flash drives are automatically spaced uniformly within that second half of the address space.
They are therefore separated by 2<sup>60</sup> bytes, which &ldquo;should be enough separation for everyone&rdquo;.
(The machine will fail to instantiate if there is any overlap between the ranges occupied by multiple drives.)
If the `start` of *any* drive is specified, then the starts for *all* drives must be specified.

When the `length` parameter is omitted, the `cartesi-machine` utility automatically sets the size of a flash drive to match the size of its image file.
Because RISC-V uses 4KiB pages, image files must have a size multiple of 4KiB.
(The `truncate` utility can be used to pad a file with zeros so its size is a multiple of 4KiB.)

For convenience, numbers can be specified in decimal or hexadecimal (e.g., `4096` or `0x1000`) and may include a suffix multiplier (i.e., `Ki` to multiply by 2<sup>10</sup>, `Mi` to multiply by 2<sup>20</sup>, and `Gi` to multiply by 2<sup>30</sup>).
They can also use the C programming language *shift left* notation to multiply by arbitrary powers of 2 (e.g. `1 << 24` meaning 2<sup>24</sup>).

When the `length` of a drive is specified, the `filename` parameter can be omitted.
In that case, the drive starts in a *pristine* state: i.e., filled with zeros.
If, however, both `length` and `filename` are specified, then the `length` must exactly match the size of image file referred to by the `filename` parameter.

The positioning of flash drives in the machine's address space has implications on certain operations, discussed in detail under [the blockchain perspective](../../blockchain/hash/), that involve the manipulation of hashes of the Cartesi Machine state.

The preferred file-system type is `ext2`.
These file-systems can be easily created with the `genext2fs` command-line utility (available in Ubuntu as its own package), and inspected or modified with the `e2ls`, `e2cp` command-line utilities (available in Ubuntu as the `e2tools` package). <a name="cartesi-machine-with-foo-flash-drive"></a>

<a name="cartesi-machine-with-foo-flash-drive"></a>

For example,
```bash
playground:~$ mkdir foo
playground:~$ echo "Hello world!" > foo/bar.txt
playground:~$ genext2fs -b 1024 -d foo foo.ext2
playground:~$ cartesi-machine \
    --flash-drive="label:foo,filename:foo.ext2" \
    -- "cat /mnt/foo/bar.txt"
```
Here, a flash drive with label `foo` is initialized with the contents of an `ext2` file-system in the image file `foo.ext2`.

:::note
The `genext2fs` command produces a file-system that includes modification times (and user IDs, permissions etc).
Furthermore, it traverses the files in the `foo/` directory in an unspecified order, progressively adding them to the `foo.ext2` file-system.
Therefore, the `genext2fs` command is *not* reproducible, in the sense that running it in different systems, or even running it twice in the same system may produce a different `./foo.ext2` file.
However, files generated once can be safely distributed.
:::

The Cartesi-provided `/sbin/init` mounts this as `/mnt/foo`.
The command executed in the machine simply copies the contents of `/mnt/foo/bar` to the terminal.
The output is
```
%machine.host.cmdline.flash
```

## Persistent flash drives

The emulator never modifies the ROM and RAM image files.
They are simply loaded into host memory and only this copy is exposed to changes caused by code executing in the target.
(The `--dump-pmas` command-line option can be used to inspect the modified copies for debugging purposes. See below.)

By default, the emulator also does *not* modify the image files for any of the flash drives either.
However, since these image files can be very large, the emulator does not pre-allocate any host memory for flash drives.
Instead, it uses the operating system's memory mapping capabilities.
The operating system reads to host memory only those pages from the image file that are actually read by code executing in the target.
(Naturally, when a state hash is requested, all image files are read from disk in their entirety and processed. See below.)
These image files are mapped to host memory in a *copy-on-write* fashion.
When code running in the target causes the emulator to write to a mapped image file, the operating system makes a copy of the page before modification and replaces the mapping to point to the fresh copy.
The image files are never written to.
For example, running the machine
```bash
playground:~$ cartesi-machine \
    --flash-drive="label:foo,filename:foo.ext2" \
    -- "ls /mnt/foo/*.txt && cp /mnt/foo/bar.txt /mnt/foo/baz.txt && ls /mnt/foo/*.txt"
```
produces the output
```
%machine.host.cmdline.persistent-flash
```
indicating that the file-system was modified, at least from the perspective of the target.
However, inspecting the `foo.ext2` image file from outside the emulator shows it is unchanged.
```
playground:~$ e2ls -al foo.ext2:*.txt
     12  100644   501    20       13 30-Jun-2020 19:40 bar.txt

```

This behavior is appropriate when the flash drives will only be used as inputs.
For output flash drives, target changes to the drives must reflect on the associated image files.
For that purpose, the parameter `shared` can be passed to command-line option `--flash-drive`, causing the imaged files to be mapped to host memory in a *shared* fashion.
For example,
```bash
playground:~$ cartesi-machine \
    --flash-drive="label:foo,filename:foo.ext2,shared" \
    -- "ls /mnt/foo/*.txt && cp /mnt/foo/bar.txt /mnt/foo/baz.txt && ls /mnt/foo/*.txt"
```
produces exactly the same output as before.
However, the backing file `foo.ext2` has now indeed been modified.
```
playground:~$ e2ls -al foo.ext2:*.txt
     12  100644   501    20       13 30-Jun-2020 19:40 bar.txt
     13  100644     0     0       13  1-Jan-1970 00:00 baz.txt

```

## Limiting execution

Typically, the `cartesi-machine` utility only returns when the Cartesi Machine halts.  For example, running
```bash
playground:~$ cartesi-machine
```
produces the output
```
%machine.host.cmdline.nothing
```
Here, the Cartesi-provided `/sbin/init` simply reports there is nothing to do do before halting gracefully.
This takes over 56M cycles to complete: time mostly spent initializing the Linux kernel.

The machine's processor includes a control and status register (CSR), named `mcycle`, that starts at 0 and is incremented after every cycle.
The maximum cycle can be specified with the command-line option `--max-mcycle=<number>`.
For example, adding the `--max-mcycle=%machine.host.cmdline.cycles-limit-exec` command-line option
```bash
playground:~$ cartesi-machine --max-mcycle=%machine.host.cmdline.cycles-limit-exec
```
produces the output
```
%machine.host.cmdline.limit-exec
```
Note the execution was interrupted before the splash screen was even completed.

The ability to limit computation to an arbitrary number of cycles is fundamental to the verifiability of Cartesi Machines, as is explained in detail under the [the blockchain perspective](../../blockchain/vg/).

## Progress feedback

A target application can inform the host of its progress by using a Cartesi-specific `/dev/yield` Linux device.
Within the target, the Linux device can be controlled in the command-line with the utility `/opt/cartesi/bin/yield`, pre-installed in the root file-system `rootfs.ext2`.
The progress feedback is accessed via the `progress <permil>` command-line option.

For example, during the execution of the loop,
```bash
playground:~$ cartesi-machine \
    --htif-yield-progress \
    -- $'for i in $(seq 0 5 1000); do yield progress $i; done'
```
the `cartesi-machine` utility receives control back from the emulator every iteration, when the target executes the `yield` utility.
(The directory `/opt/cartesi/bin/` is in the default search path for executable setup by `/sbin/init`.)
If the `--htif-yield-progress` command-line option to `cartesi-machine` is omitted, the emulator essentially ignores yield requests from the target.
Each time `cartesi-machine` receives control due to a yield, it prints a progress message (shown at 44% below) and resumes the emulator so it can continue working.
```

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Progress:  44.00
```
This feature is most useful when the emulator is controlled programmatically, via its Lua, C++, or gRPC interfaces, where Cartesi Machines typically run disconnected from the console.
In these situations, the progress device can be used to drive a dynamic user interface element that reassures users progress is being made during long, silent computations.
Its handling by `cartesi-machine`, which does have access to the console, is simply to help with prototyping and debugging.

The protocols followed by the `yield` utility to interact with the `/dev/yield` driver and by the driver itself to communicate with the HTIF device are explained in detail under the [target perspective](../../target/architecture/).

## State hashes

The `cartesi-machine` utility can also be used to output Cartesi Machine state hashes.
State hashes are Merkle tree root hashes of the entire 64-bit address space of the Cartesi Machine, where the leaves are aligned 64-bit words.
Since Cartesi Machines are transparent, the contents of this address space encompass the entire machine state, including all processor CSRs and general-purpose registers, the contents of RAM and ROM, of all flash drives, and of all other devices connected to the board.
State hashes therefore work as cryptographic signatures of the machine, and implicitly of the computation they are about to execute.

To obtain the state hash right before execution starts, use the command-line option `--initial-hash`.
Conversely, to obtain the state hash right after execution is done, use the option `--final-hash`.
For example,
```bash
playground:~$ cartesi-machine \
    --max-mcycle=%machine.host.cmdline.cycles-limit-exec \
    --initial-hash \
    --final-hash
```
produces the output
```
%machine.host.cmdline.state-hashes-limit-exec
```
The initial state hash `%machine.host.cmdline.state-hashes-initial...` is the Merkle tree root hash for the initial Cartesi Machine state.
Since Cartesi Machines are reproducible, the initial state hash also works as a *future* on the entire computation itself.
In other words, the &ldquo;final state hash&rdquo; `%machine.host.cmdline.state-hashes-final-limit-exec...` is the &ldquo;only&rdquo; possible outcome for the `--final-hash` at cycle %machine.host.cmdline.cycles-limit-exec, given the result of the `--initial-hash` operation was `%machine.host.cmdline.state-hashes-initial...`.

:::info
The scare quotes around &ldquo;only&rdquo; are pedantic.
It is true that there are a multitude of machine states that produce the same state hash.
After all, the Keccak-256 state hashes fit in 256-bits, whereas machine states can take gigabytes.
There are therefore many more possible machine states than possible state hashes.
By the pigeonhole principle, there must be multiple machines with the same hash (i.e., hash collisions).
However, given only the state hash, finding a Cartesi Machine with that state hash should be virtually impossible.
Given a Cartesi Machine and its state hash, finding a *second* (distinct) Cartesi Machine with the same state hash should also be virtually impossible.
Even finding two different Cartesi Machines that have the same state hash (any hash) should be virtually impossible.
Cryptographic hash functions, such as Keccak-256, were designed *specifically* to have these properties.
:::

Allowing the machine to run until it halts
```bash
playground:~$ cartesi-machine \
    --initial-hash \
    --final-hash
```
produces instead the output
```
%machine.host.cmdline.state-hashes-no-limit
```
Naturally, the initial state hash is the same as before.
However, the final state hash `%machine.host.cmdline.state-hashes-final-no-limit...` now pertains to cycle %machine.host.cmdline.state-hashes-cycles-no-limit, where the machine is halted.
This is the &ldquo;only&rdquo; possible state hash for a *halted* machine that started from state hash `%machine.host.cmdline.state-hashes-initial...`.

## Persistent Cartesi Machines

At any point in their execution, Cartesi Machines can be stored to disk.
A stored machine can later be loaded to continue its execution from where it left off.
To store a machine to a given `<directory>`, use the command-line option `--store=<directory>`.
The machine is stored as it was right before `cartesi-machine` returns to the command line.
For example, to store the machine corresponding to state hash `%machine.host.cmdline.state-hashes-final-limit-exec...`
```bash
playground:~$ cartesi-machine \
    --max-mcycle=%machine.host.cmdline.cycles-limit-exec \
    --store="machine-%machine.host.cmdline.state-hashes-final-limit-exec"
```
This command creates a directory `machine-%machine.host.cmdline.state-hashes-final-limit-exec/`, containing a variety of files that allow the Cartesi Machine emulator to recreate a machine state.
Every image file is copied into the directory, so no external dependencies remain.

:::note
If the machine initialization involved large image files or a considerable amount of RAM, this operation may consume significant disk space.
It will also take the time required by the copying of image files into the directory, and by the computation of the state hash.
:::

If the directory already exists, the operation will fail.
This prevents the overwriting of a Cartesi Machine by mistake.
Once created, the directory can be compressed and transferred to other hosts.
To restore the corresponding Cartesi Machine, use the command-line option `--load=<directory>`.
For example,
```bash
playground:~$ cartesi-machine \
    --load="machine-%machine.host.cmdline.state-hashes-final-limit-exec" \
    --initial-hash \
    --final-hash
```
produces the output
```
%machine.host.cmdline.persistent-machine
```
Note that, other than `--load`, no initialization command-line options were used.
These initializations were used to define the machine before it was stored: their values are implicitly encoded in the stored state.
The machine continues from where it left off, and reaches the same final state hash `%machine.host.cmdline.state-hashes-final-no-limit...`, as if it had never been interrupted.

Note also that the initial state hash `%machine.host.cmdline.state-hashes-final-limit-exec...` after `--load` matches the final state hash before `--store`.
After all, they are state hashes concerning the state of the same machine at the same cycle.
In fact, `--store` writes this state hash inside the directory, and `--load` verifies that the state hash of the restored machine matches what it found in the directory.

The `cartesi-machine-stored-hash` command-line utility can be used to extract the state hash from a stored Cartesi Machine:

```bash
playground:~$ cartesi-machine-stored-hash machine-%machine.host.cmdline.state-hashes-final-limit-exec
%machine.host.cmdline.persistent-stored-hash
```

## Cartesi Machine templates

*Templates* are one of the key uses for Cartesi Machines stored to disk.
Cartesi Machine templates are machines in which the contents of one or more flash drives are still unknown.
To put it another way, Cartesi Machine templates behave like functions whose parameters are the yet-to-be-defined contents of one or more flash drives.

As discussed in detail under [the blockchain perspective](../../blockchain/hash/), starting from template hashes, the hashes of the flash drives, and a small amount of [additional information](#sibling-hashes), it is possible to obtain the state hash of the *instantiated template*&mdash;the state hash for a Cartesi Machine with drives replaced by their actual content.
This is how a smart contract can specify a computation to be performed off-chain over arbitrary input.
Starting from the template hash, and in possession of the flash drive hashes, it instantiates the template, generating the initial state hash for the corresponding Cartesi Machine.

As an example, consider a Cartesi Machine that operates as an arbitrary-precision arithmetic expression evaluator.
The machine will take the expression in text format, inside a raw input flash drive labelled `input`, and will copy the output in text format into a raw output flash drive, labelled `output` (`shared`, of course, so the output persists after the emulator is done).

Raw flash drives are flash drives that do not contain file-systems.
Instead, they contain data in any application-specific format.
The `dd` or `devio` command-line utilities can be used to read data from or write data to raw flash drives.

The `bc` command-line utility is the perfect tool to evaluate the arithmetic expressions.
The command passed to `cartesi-machine` below reads the contents of the raw input flash drive using the `dd` command-line utility, extracts a zero-terminated string from it using a tiny Lua script run by the `lua` interpreter, pipes the result to `bc`, and finally uses `dd` again to write its results to the raw output flash drive.
Here is the sample playground session
```bash
playground:~$ rm -f output.raw
playground:~$ truncate -s 4K output.raw
playground:~$ echo "6*2^1024 + 3*2^512" > input.raw
playground:~$ truncate -s 4K input.raw
playground:~$ cartesi-machine \
    --flash-drive="label:input,length:1<<12,filename:input.raw" \
    --flash-drive="label:output,length:1<<12,filename:output.raw,shared" \
    -- $'dd status=none if=$(flashdrive input) | lua -e \'print((string.unpack("z",  io.read("a"))))\' | bc | dd status=none of=$(flashdrive output)'
playground:~$ luapp5.3 -e 'print((string.unpack("z", io.read("a"))))' < output.raw
```

Using the `truncate` command-line utility, the session creates a 4KiB file `output.raw` containing only zeros to serve as the output drive image.
Then, it creates the `input.raw` file for use as the input drive image containing the expression `6*2^1024 + 3*2^512\n` to be evaluated.
This file is then padded with zeros to 4KiB in size by the `truncate` utility.
The session then invokes the `cartesi-machine` command-line utility to evaluate the expression.
The output of the `cartesi-machine` command is
```
%machine.host.cmdline.templates-run
```
Once the emulator returns, the session uses a tiny Lua script, run by the playground's `luapp5.3` Lua interpreter, to print the contents of the output drive, which reads
```
10786158809173895446375831144734148401707861873653839436405804869463\
96054833005778796250863934445216126720683279228360145952738612886499\
73495708458383684478649003115037698421037988831222501494715481595948\
96901677837132352593468675094844090688678579236903861342030923488978\
36036892526733668721977278692363075584
```
This is indeed the result of 6&times;2<sup>1024</sup>+3&times;2<sup>512</sup>.

To create the template, simply omit the input and output image filenames.
This will cause the Cartesi Machine to assume both drives are filled with zeros.
Then, limit the computation with `--max-mcycle=0`, to prevent the Cartesi Machine from running.
Finally, use the `--store="calculator-template"` command-line option to store the Cartesi Machine template.
The `--final-hash` command-line option prints the resulting template hash.
```
playground:~$ cartesi-machine \
    --flash-drive="label:input,length:1<<12" \
    --flash-drive="label:output,length:1<<12" \
    --max-mcycle=0 \
    --final-hash \
    --store="calculator-template" \
    -- $'dd status=none if=$(flashdrive input) | lua -e \'print((string.unpack("z", io.read("a"))))\' | bc | dd status=none of=$(flashdrive output)'
```
The result is as follows
```
%machine.host.cmdline.templates-store
```
The directory `calculator-template/` now contains the Cartesi Machine template.
And indeed, the stored template hash is `%machine.host.cmdline.templates-trunc-hash...`.

```bash
playground:~$ cartesi-machine-stored-hash calculator-template/
%machine.host.cmdline.templates-hash
```
Templates are typically used by programs that control the emulator with the C++, Lua, or gRPC interfaces.
This is how templates are created for use with the Descartes SDK.

The `--replace-flash-drive=start:<start>,length:<length>,filename:<filename>` command-line option of the `cartesi-machine` utility can be used to replace an existing flash drive right before a machine is run.
The flash drive to be replaced must be specified by its `start` and `length`.
(Labels do not identify flash drives, they only provide convenient names for partitions.)

This functionality can be used to test templates.
For example, the following command loads the calculator template, and replaces its pristine input drive with a drive containing the contents of the `input.raw` file.
Then, it replaces the pristine output drive so the machine saves results in the file `output.raw`.

```bash
playground:~$ rm -f output.raw
playground:~$ truncate -s 4K output.raw
playground:~$ echo "6*2^1024 + 3*2^512" > input.raw
playground:~$ truncate -s 4K input.raw
playground:~$ cartesi-machine \
    --load="calculator-template" \
    --replace-flash-drive="start:0x9000000000000000,length:1<<12,filename:input.raw" \
    --replace-flash-drive="start:0xA000000000000000,length:1<<12,filename:output.raw,shared"
playground:~$ luapp5.3 -e 'print((string.unpack("z", io.read("a"))))' < output.raw
```
The result of running the command is, as expected,
```
10786158809173895446375831144734148401707861873653839436405804869463\
96054833005778796250863934445216126720683279228360145952738612886499\
73495708458383684478649003115037698421037988831222501494715481595948\
96901677837132352593468675094844090688678579236903861342030923488978\
36036892526733668721977278692363075584
```

## State value proofs

The `cartesi-machine` command-line utility can generate proofs concerning the contents of the machine state.
To generate a proof concerning the state as it is before the machine starts running, use the `--initial-proof=address:<number>,log2_size:<number>[,filename=<filename>]` option.
For proofs concerning the state after the emulator is done, use `--final-proof` instead.
In either case, the filename field is optional.
When provided, the proof will be written to the corresponding file.
Otherwise, the contents will be displayed on screen.

*State value proofs* are proofs that a given node in the Merkle tree of the Cartesi Machine state has a given label (i.e., a given associated hash).
Each Merkle tree node covers a contiguous range of the machine's 64-bit address space.
The size of a range is always a power of 2 (i.e., the `<log2_size>` power of 2).
Since the leaves have size 8 (for 64-bits), the valid values for `<log2_size>` are 3&hellip;64.
The range corresponding to each node starts at an `<address>` that is a multiple of its size.

For example, to generate a proof that the Cartesi Machine template above indeed contains a pristine input drive, use the command line
```bash
playground:~$ cartesi-machine \
	--load="calculator-template" \
    --max-mcycle=0 \
    --initial-hash \
    --initial-proof="address:0x9000000000000000,log2_size:12,filename:pristine-input-proof"
```
Recall the first flash drive, the one with the `rootfs.ext2` image file, is present by default, and is automatically placed at starting address `0x8000000000000000`.
The input flash drive is therefore the second drive.
It is automatically spaced by 2<sup>60</sup> bytes relative to the first drive, so that its starting address is `0x9000000000000000`.

The output of the command is
```
%machine.host.cmdline.proofs-pristine-run
```

In addition, the `pristine-input-proof` file now contains a JSON structure with the requested proof
```js title="pristine-input-proof"
%machine.host.cmdline.proofs-pristine-json
```
The `root_hash` value `%machine.host.cmdline.templates-trunc-hash...` is the expected initial state hash seen in the output of the `cartesi-machine` command.
The `address` value `10376293541461622784` is the same as `0x9000000000000000` in decimal.
The `log2_size` value `12` refers to the size of the 4KiB input drive.
The `target_hash` value `d8b96e5b7...` in the proof gives the hash of the input drive.

The hash of the input drive can be also computed externally with the `merkle-tree-hash` command-line utility.
The utility can produce the hash of any file with a power-of-2 size.
The `--tree-log2-size=<log2_size>` option specifies the size.
If an input file is smaller than the specified size, the utility assumes the missing data is composed entirely of bytes 0.
The utility deals efficiently with zero paddings of any size because pristine hashes for all power-of-2 sizes can be precomputed.
For example, to quickly generate the hash for a pristine input with 4KiB size, run
```bash
playground:~$ head -c 0 | merkle-tree-hash --tree-log2-size=12
d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0
```
As expected, the hash values match.

The <a name="sibling-hashes"> `sibling_hashes` </a> array contains the hashes of the siblings to all nodes in the path from the root all the way down to the target node (excluding the root, which has no sibling).
In a process explained in the [blockchain perspective](../../blockchain/hash/), using the `address` field, the `target_hash` hash, and the `sibling_hashes` array, it is possible to go up the tree computing the hashes along the path, until the root hash is produced.
If the root hash obtained by this process matches the expected root hash, the proof is valid.
Otherwise, something is amiss.
(Incidentally, from the hash of its sibling, the last entry in `sibling_hashes`, it is possible to ascertain that the neighboring range to the input drive also contains 4KiB of bytes 0.)

To compute the hash for the desired `input.raw` file with contents `6*2^1024 + 3*2^512\n`, padded with zeros, run
```bash
playground:~$ echo "6*2^1024 + 3*2^512" | merkle-tree-hash --tree-log2-size=12
2c92c99754e85e3e2a29edd84228a62b051f9f55a5563f8decc7c6d5d9d8ef64
```

Using a process similar to the proof verification described above, it is possible to go up the Merkle tree for the template using the `sibling_hashes` array in the proof, but starting from the hash `2c92c997...` of the desired `input.raw` image rather than hash `d8b96e5b...` of the template's pristine drive.
The result is the initial state hash for the instantiated template: the same that can be seen in the initial state hash produced by the `cartesi-machine` command-line
```bash
playground:~$ echo "6*2^1024 + 3*2^512" > input.raw
playground:~$ truncate -s 4K input.raw
playground:~$ cartesi-machine \
    --load="calculator-template" \
    --replace-flash-drive="start:0x9000000000000000,length:1<<12,filename:input.raw" \
    --initial-hash \
    --initial-proof="address:0x9000000000000000,log2_size:12,filename:input-proof" \
	--max-mcycle=0
```

The contents of the `input-proof` are

```js title="input-proof"
%machine.host.cmdline.proofs-input-json
```
The `target_hash` value `2c92c997...` reflects the hash computed for the input, whereas `root_hash` value `%machine.host.cmdline.proofs-input-roothash...` differs from `%machine.host.cmdline.templates-trunc-hash...` obtained for template, as expected.
Moreover, the `sibling_hashes` entries in the template Cartesi Machine and in the instantiated Cartesi Machine remain the same, reflecting the fact that there were no other changes in the machine's initial state.

Another useful proof is the one for the *output* drive, once the machine is halted.
To obtain this proof, run
```bash
playground:~$ rm -f output.raw
playground:~$ truncate -s 4K output.raw
playground:~$ echo "6*2^1024 + 3*2^512" > input.raw
playground:~$ truncate -s 4K input.raw
playground:~$ cartesi-machine \
    --load="calculator-template" \
    --replace-flash-drive="start:0x9000000000000000,length:1<<12,filename:input.raw" \
    --replace-flash-drive="start:0xa000000000000000,length:1<<12,filename:output.raw,shared" \
    --final-hash \
    --final-proof="address:0xa000000000000000,log2_size:12,filename:output-proof"
```

This produces the output

```
%machine.host.cmdline.proofs-output-run
```
The contents of the `output-proof` are
```js title="output-proof"
%machine.host.cmdline.proofs-output-json
```
Note how the `root_hash` field in the proof matches the final state hash `%machine.host.cmdline.proofs-output-roothash...` output by the `cartesi-machine` command-line utility.

To see that the `target_hash` field matches the `output.raw` drive, use the `merkle-tree-hash` command-line utility:
```bash
playground:~$ merkle-tree-hash --tree-log2-size=12 < output.raw
b15a6b8aab8a423c725f9ad55fd46c4481ba91008f3a01593192de37a7a41565
```

The `cartesi-machine` command-line utility accepts an arbitrary number of `--initial-proof` and `--final-proof` parameters.
They are computed one-by-one, and either printed or stored in the specified files, as requested.

To read more about proofs, refer to the [the blockchain perspective](../../blockchain/hash/).

## Rarely used options

:::warning
This is an advanced section, not needed by regular users of the Cartesi platform.
:::

The command-line option `--append-rom-bootargs=<string>` can be used to append any `<string>` to the kernel command-line.
A detailed description of all kernel command-line parameters is beyond the scope of this document.
Please refer to the appropriate [section of the kernel documentation](https://www.kernel.org/doc/html/v5.5/admin-guide/kernel-parameters.html).
As an example, to prevent clutter in the console, the `cartesi-machine` utility automatically adds the `quiet` option to the kernel command-line, disabling most log messages.
To override this setting and see more of the log messages output to console, use the `loglevel=<n>` parameter.
```bash
playground:~$ cartesi-machine --append-rom-bootargs="loglevel=8"
```
The output is
```
%machine.host.cmdline.rarely-append-bootargs
```

The command-line option `--periodic-hashes=<number-period>[,<number-start>]` causes the command-line utility to periodically obtain and print the state hash.
The `<number-period>` argument gives the distance between hashes in cycles. The optional `<number-start>` argument gives the starting cycle for the periodic hashes. (Both `--initial-hash` and `--final-hash` are implied by this option.)

For example, to see the last 10 state hashes from the calculator machine computation, run the command
```bash
playground:~$ echo "6*2^1024 + 3*2^512" > input.raw
playground:~$ truncate -s 4K input.raw
playground:~$ cartesi-machine \
    --load="calculator-template" \
    --replace-flash-drive="start:0x9000000000000000,length:1<<12,filename:input.raw" \
    --periodic-hashes=1,%machine.host.cmdline.rarely-periodic-initial-cycle
```
The output is

```
%machine.host.cmdline.rarely-periodic-hashes
```

The command-line option `--dump-pmas` causes the emulator to dump the contents of all mapped spans in the address space to files.
Each span produces a file `<start>--<length>.bin`.
Every other byte in the address space has value 0.
This is useful to inspect the entire state of the machine from outside the emulator.

The command-line option, `--dump-machine-config` will be explained under the [Lua interface](lua.md) to Cartesi Machines.
In a nutshell, it generates the `machine_config` structure that can be used to initialize the exact same Cartesi Machine that the `cartesi-machine` command-line utility will use.

The remaining options in the command-line utility `cartesi-machine` are mostly useful for low-level tests and debugging.
As such, they require some context.

During verification, the blockchain mediates a *verification game* between the disputing parties.
This process is explained in detail under the [the blockchain perspective](../../blockchain/vg/).
In a nutshell, both parties started from a Cartesi Machine that has a known and agreed upon initial state hash.
(E.g., an agreed upon template that was instantiated with an agreed upon input drive.)
At the end of the computation, these parties now disagree on the state hash for the halted machine.
The state hash evolves as the machine executes steps in its fetch-execute loop.
The first stage of the verification game therefore searches for the *step of disagreement*: the particular cycle such that the parties agree on the state hash before the step, but disagree on the state hash after the step.
Once this step of disagreement is identified, one of the parties sends to the blockchain a log of state accesses that happen along the step, including cryptographic proofs for every value read from or written to the state.
This log proves to the blockchain that the execution of the step transitions the state in such a way that it reaches the state hash claimed by the submitting party.

The `--step` command-line option instructs `cartesi-machine` to dump to screen an abridged, user-friendly version of this state access log.

For the sake of completeness, consider the example in which the Cartesi Machine was stopped while it drew the splash screen.
The example below shows the step it was about to execute
```bash
playground:~$ cartesi-machine \
    --max-mcycle=%machine.host.cmdline.cycles-limit-exec \
    --step > /dev/null
```
and produces the log
```
%machine.host.cmdline.rarely-step
```
Understanding these logs in detail is unnecessary for all but the most low-level internal development at Cartesi.
It requires deep knowledge of not only RISC-V architecture, but also how Cartesi's emulator implements it.
The material is therefore beyond the scope of this document.

This particular example, however, was hand-picked for illustration purposes.
The RISC-V instruction being executed, `sd`, writes the 64-bit word `0x010100000000000a` to address `0x40008000` (access&nbsp;#23).
This is the memory-mapped address of HTIF's `tohost` CSR.
The value refers to the console subdevice (`DEV=0x01`) , command `putchar` (`CMD=0x01`), and causes the device to output a line-feed (`DATA=0x0a`) to the emulator's console.
I.e., the instruction is completing the row `       \    / CARTESI` in the splash screen.

The command-line option `--json-log=<filename>` outputs a machine-readable version of the step log *for each cycle* executed by the emulator.
It is used by internal integration tests that verify the consistency between the Cartesi Machine as implemented by the off-chain emulator and as implemented by the on-chain step verification function.
Needless to say, even for brief computations, the resulting log files can be *very* large.
